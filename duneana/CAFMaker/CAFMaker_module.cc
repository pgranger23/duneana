////////////////////////////////////////////////////////////////////////
//
// \file CAFMaker_module.cc
//
// Chris Marshall's version
// Largely based on historical FDSensOpt/CAFMaker_module.cc
//
///////////////////////////////////////////////////////////////////////

#ifndef CAFMaker_H
#define CAFMaker_H

// Generic C++ includes
#include <iostream>

// Framework includes
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Core/EDAnalyzer.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/SubRun.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"
#include "art_root_io/TFileService.h"

#include "duneanaobj/StandardRecord/StandardRecord.h"
#include "duneanaobj/StandardRecord/SRGlobal.h"

#include "duneanaobj/StandardRecord/Flat/FlatRecord.h"

//#include "Utils/AppInit.h"
#include "nusimdata/SimulationBase/GTruth.h"
#include "nusimdata/SimulationBase/MCTruth.h"
#include "nusimdata/SimulationBase/MCFlux.h"
#include "larcoreobj/SummaryData/POTSummary.h"
#include "dunereco/FDSensOpt/FDSensOptData/MVASelectPID.h"
#include "dunereco/FDSensOpt/FDSensOptData/EnergyRecoOutput.h"
#include "dunereco/CVN/func/InteractionType.h"
#include "dunereco/CVN/func/Result.h"
#include "dunereco/RegCNN/func/RegCNNResult.h"

// dunerw stuff
#include "systematicstools/interface/ISystProviderTool.hh"
#include "systematicstools/utility/ParameterAndProviderConfigurationUtility.hh"
#include "systematicstools/utility/exceptions.hh"
#include "nugen/EventGeneratorBase/GENIE/GENIE2ART.h"
//#include "systematicstools/utility/md5.hh"

// root
#include "TFile.h"
#include "TTree.h"
#include "TH1D.h"
#include "TH2D.h"

// pdg
#include "Framework/ParticleData/PDGCodes.h"
#include "Framework/ParticleData/PDGUtils.h"
#include "Framework/ParticleData/PDGLibrary.h"

// genie
#include "Framework/EventGen/EventRecord.h"
#include "Framework/GHEP/GHepParticle.h"

namespace caf {

  class CAFMaker : public art::EDAnalyzer {

    public:

      explicit CAFMaker(fhicl::ParameterSet const& pset);
      virtual ~CAFMaker();
      void beginJob() override;
      void endJob() override;
      void beginSubRun(const art::SubRun& sr) override;
      void endSubRun(const art::SubRun& sr) override;
      void analyze(art::Event const & evt) override;


    private:
      void AddGlobalTreeToFile(TFile* f, SRGlobal& global, std::vector<std::vector<double>> &shifts);
      void FillTruthInfo(caf::StandardRecord& sr,
                         std::vector<simb::MCTruth> const& truth,
                         std::vector<simb::MCFlux> const& flux,
                         art::Event const& evt);
      // genie::EventRecord buildEventRecord(art::Event const & evt);

      std::string fMVASelectLabel;
      std::string fMVASelectNueLabel;
      std::string fMVASelectNumuLabel;

      std::string fCVNLabel;
      std::string fRegCNNLabel;

      std::string fEnergyRecoNueLabel;
      std::string fEnergyRecoNumuLabel;
      std::string fMVAMethod;

      TFile* fOutFile = 0;
      TTree* fTree = 0;
      TTree* fMetaTree = 0;

      TFile* fFlatFile = 0;
      TTree* fFlatTree = 0;
      flat::Flat<caf::StandardRecord>* fFlatRecord = 0;

      double meta_pot;
      int meta_run, meta_subrun, meta_version;

      systtools::provider_list_t fSystProviders;
      std::vector<std::vector<float>> fDefaultSystWgt;
      std::vector<float> fDefaultCvWgt;
      genie::EventRecord *genie_rec = nullptr;

  }; // class CAFMaker


  //------------------------------------------------------------------------------
  CAFMaker::CAFMaker(fhicl::ParameterSet const& pset)
    : EDAnalyzer(pset)
  {
    fMVASelectLabel = pset.get<std::string>("MVASelectLabel");
    fMVASelectNueLabel = pset.get<std::string>("MVASelectNueLabel");
    fMVASelectNumuLabel = pset.get<std::string>("MVASelectNumuLabel");
    fCVNLabel = pset.get<std::string>("CVNLabel");
    fRegCNNLabel = pset.get<std::string>("RegCNNLabel");

    fEnergyRecoNueLabel = pset.get<std::string>("EnergyRecoNueLabel");
    fEnergyRecoNumuLabel = pset.get<std::string>("EnergyRecoNumuLabel");

    // Get DUNErw stuff from its fhicl, which should be included on the CAFMaker config file
    if( !pset.has_key("generated_systematic_provider_configuration") ) {
     std::cout << "[ERROR]: Could not find producer key: "
                  "\"generated_systematic_provider_configuration\". This should "
                  "contain a list of configured systematic providers generated by "
                  "GenerateSystProviderConfig." << std::endl;
     return;
    }

    fhicl::ParameterSet syst_provider_config = pset.get<fhicl::ParameterSet>("generated_systematic_provider_configuration");

    // TODO - this was crashing with NULL genie Registry
    fSystProviders = systtools::ConfigureISystProvidersFromParameterHeaders(syst_provider_config);


    if(pset.get<bool>("CreateCAF", true)){
      fOutFile = new TFile("caf.root", "RECREATE");
    }

    if(pset.get<bool>("CreateFlatCAF", true)){
      // LZ4 is the fastest format to decompress. I get 3x faster loading with
      // this compared to the default, and the files are only slightly larger.
      fFlatFile = new TFile("flatcaf.root", "RECREATE", "",
                            ROOT::CompressionSettings(ROOT::kLZ4, 1));
    }
  }

  //------------------------------------------------------------------------------
  caf::CAFMaker::~CAFMaker()
  {
  }

  //------------------------------------------------------------------------------
  void CAFMaker::beginJob()
  {
    if(fOutFile){
      fOutFile->cd();
      fTree = new TTree("cafTree", "cafTree");

      // Create the branch. We will update the address before we write the tree
      caf::StandardRecord* rec = 0;
      std::vector<float>* cvwgt = 0;
      std::vector<std::vector<float>>* xsSyst_wgt = 0;
      fTree->Branch("rec", &rec);
      fTree->Branch("cvwgt", &cvwgt);
      fTree->Branch("xsSyst_wgt", &xsSyst_wgt);
      fTree->Branch("genie_rec", &genie_rec);
    }

    if(fFlatFile){
      fFlatFile->cd();
      fFlatTree = new TTree("cafTree", "cafTree");

      fFlatRecord = new flat::Flat<caf::StandardRecord>(fFlatTree, "rec", "", 0);
    }


    fMetaTree = new TTree("meta", "meta");

    fMetaTree->Branch("pot", &meta_pot, "pot/D");
    fMetaTree->Branch("run", &meta_run, "run/I");
    fMetaTree->Branch("subrun", &meta_subrun, "subrun/I");
    fMetaTree->Branch("version", &meta_version, "version/I");

    meta_pot = 0.;
    meta_version = 1;


    caf::SRGlobal global;

    std::vector<std::vector<double>> shifts;

    // make DUNErw variables
    for( auto &sp : fSystProviders ) {
      for(const systtools::SystParamHeader& head: sp->GetSystMetaData()){
        std::cout << "Adding reweight " << head.systParamId << " for " << head.prettyName << " with " << head.paramVariations.size() << " shifts" << std::endl;

        caf::SRSystParamHeader hdr;
        hdr.nshifts = head.paramVariations.size();
        hdr.name = head.prettyName;
        hdr.id = head.systParamId; // TODO is this necessary?
        shifts.push_back(std::vector<double>(head.paramVariations));

        global.wgts.params.push_back(hdr);
        fDefaultSystWgt.push_back(std::move(std::vector<float>(head.paramVariations.size(), 1.0)));
        fDefaultCvWgt.push_back(1);
      }
    }

    if(fOutFile) AddGlobalTreeToFile(fOutFile, global, shifts);
    if(fFlatFile) AddGlobalTreeToFile(fFlatFile, global, shifts);
  }

  //------------------------------------------------------------------------------
  void CAFMaker::AddGlobalTreeToFile(TFile* f, SRGlobal& global, std::vector<std::vector<double>> &shifts)
  {
    f->cd();
    TTree* globalTree = new TTree("globalTree", "globalTree");
    caf::SRGlobal* pglobal = &global;
    TBranch* br = globalTree->Branch("global", "caf::SRGlobal", &pglobal);
    TBranch* br_shifts = globalTree->Branch("shifts", &shifts);
    if(!br) abort();
    if(!br_shifts) abort();
    globalTree->Fill();
    globalTree->Write();
  }

  void CAFMaker::FillTruthInfo(caf::StandardRecord& sr,
                               std::vector<simb::MCTruth> const& truth,
                               std::vector<simb::MCFlux> const& flux,
                               art::Event const& evt)
  {
    for(size_t i=0; i<truth.size(); i++){

      if(i>1){
        mf::LogWarning("CAFMaker") << "Skipping MC truth index " << i;
        continue;
      }

      sr.isFD   = 1; // always FD
      sr.isFHC  = 999; // don't know how to get this?
      sr.isCC   = !(truth[i].GetNeutrino().CCNC());  // ccnc is 0=CC 1=NC
      sr.nuPDG  = truth[i].GetNeutrino().Nu().PdgCode();
      sr.nuPDGunosc = flux[i].fntype;
      sr.mode   = truth[i].GetNeutrino().Mode(); //0=QE/El, 1=RES, 2=DIS, 3=Coherent production; this is different than mode in ND
      sr.Ev     = truth[i].GetNeutrino().Nu().E();
      sr.Q2     = truth[i].GetNeutrino().QSqr();
      sr.W      = truth[i].GetNeutrino().W();
      sr.X      = truth[i].GetNeutrino().X();
      sr.Y      = truth[i].GetNeutrino().Y();
      sr.NuMomX = truth[i].GetNeutrino().Nu().Momentum().X();
      sr.NuMomY = truth[i].GetNeutrino().Nu().Momentum().Y();
      sr.NuMomZ = truth[i].GetNeutrino().Nu().Momentum().Z();

      sr.vtx_x  = truth[i].GetNeutrino().Lepton().Vx();
      sr.vtx_y  = truth[i].GetNeutrino().Lepton().Vy();
      sr.vtx_z  = truth[i].GetNeutrino().Lepton().Vz();

      //Lepton stuff
      sr.LepPDG   = truth[i].GetNeutrino().Lepton().PdgCode();
      sr.LepMomX  = truth[i].GetNeutrino().Lepton().Momentum().X();
      sr.LepMomY  = truth[i].GetNeutrino().Lepton().Momentum().Y();
      sr.LepMomZ  = truth[i].GetNeutrino().Lepton().Momentum().Z();
      sr.LepE     = truth[i].GetNeutrino().Lepton().Momentum().T();
      sr.LepNuAngle = truth[i].GetNeutrino().Nu().Momentum().Vect().Angle(truth[i].GetNeutrino().Lepton().Momentum().Vect());

      sr.nP     = 0;
      sr.nN     = 0;
      sr.nipip  = 0;
      sr.nipim  = 0;
      sr.nipi0  = 0;
      sr.nikp   = 0;
      sr.nikm   = 0;
      sr.nik0   = 0;
      sr.niem   = 0;
      sr.niother = 0;
      sr.nNucleus = 0;
      sr.nUNKNOWN = 0;

      sr.eP = 0.;
      sr.eN = 0.;
      sr.ePip = 0.;
      sr.ePim = 0.;
      sr.ePi0 = 0.;
      sr.eOther = 0.;

      float weight = 0;
      auto gt = evt.getHandle< std::vector<simb::GTruth> >("generator");
      if ( gt ){
        auto gtruth = (*gt)[0];
        weight = gtruth.fweight;
        genie_rec = evgb::RetrieveGHEP(truth[0], gtruth);
      }
        
      else
        mf::LogWarning("CAFMaker") << "No GTruth.";

      sr.pot = weight;

      for( int p = 0; p < truth[i].NParticles(); p++ ) {
        if( truth[i].GetParticle(p).StatusCode() == genie::kIStHadronInTheNucleus ) {

          int pdg = truth[i].GetParticle(p).PdgCode();
          double ke = truth[i].GetParticle(p).E() - truth[i].GetParticle(p).Mass();
          if     ( pdg == genie::kPdgProton ) {
            sr.nP++;
            sr.eP += ke;
          } else if( pdg == genie::kPdgNeutron ) {
            sr.nN++;
            sr.eN += ke;
          } else if( pdg == genie::kPdgPiP ) {
            sr.nipip++;
            sr.ePip += ke;
          } else if( pdg == genie::kPdgPiM ) {
            sr.nipim++;
            sr.ePim += ke;
          } else if( pdg == genie::kPdgPi0 ) {
            sr.nipi0++;
            sr.ePi0 += ke;
          } else if( pdg == genie::kPdgKP ) {
            sr.nikp++;
            sr.eOther += ke;
          } else if( pdg == genie::kPdgKM ) {
            sr.nikm++;
            sr.eOther += ke;
          } else if( pdg == genie::kPdgK0 || pdg == genie::kPdgAntiK0 || pdg == genie::kPdgK0L || pdg == genie::kPdgK0S ) {
            sr.nik0++;
            sr.eOther += ke;
          } else if( pdg == genie::kPdgGamma ) {
            sr.niem++;
            sr.eOther += ke;
          } else if( genie::pdg::IsHadron(pdg) ) {
            sr.niother++; // charm mesons, strange and charm baryons, antibaryons, etc.
            sr.eOther += ke;
          } else if( genie::pdg::IsIon(pdg) ) {
            sr.nNucleus++;
          } else {
            sr.nUNKNOWN++;
          }

        }
      }

      // Reweighting variables

      // Consider
      // systtools::ScrubUnityEventResponses(er);

      sr.total_xsSyst_cv_wgt = 1;
      sr.xsSyst_wgt = fDefaultSystWgt;
      sr.cvwgt = fDefaultCvWgt;

      for(auto &sp : fSystProviders ) {
        std::unique_ptr<systtools::EventAndCVResponse> syst_resp = sp->GetEventVariationAndCVResponse(evt);
        if( !syst_resp ) {
          std::cout << "[ERROR]: Got nullptr systtools::EventResponse from provider "
                    << sp->GetFullyQualifiedName();
          abort();
        }

        // The iteration order here is the same as how we filled SRGlobal, so
        // no need to do any work to make sure they align.
        //
        // NB this will all go wrong if we ever support more than one MCTruth
        // per event.
        for(const std::vector<systtools::VarAndCVResponse>& resp: *syst_resp){
          for(const systtools::VarAndCVResponse& it: resp){
            // Need begin/end to convert double to float
            // sr.xsSyst_wgt.emplace_back(it.responses.begin(), it.responses.end());
            sr.xsSyst_wgt[it.pid] = std::vector<float>(it.responses.begin(), it.responses.end());
            sr.cvwgt[it.pid] = it.CV_response;
            sr.total_xsSyst_cv_wgt *= it.CV_response;
            // std::cout << "ID: " << it.pid << std::endl;
          }
          // std::cout << sp->GetFullyQualifiedName() << " -> SIZE: " << resp.size() << std::endl;
          
        }
      }
      std::cout << "LENGTH SYSTEMATICS RESPONSE: " << sr.xsSyst_wgt.size() << std::endl;
    } // loop through MC truth i
  }

  //------------------------------------------------------------------------------
  void CAFMaker::beginSubRun(const art::SubRun& sr)
  {
    auto pots = sr.getHandle< sumdata::POTSummary >("generator");
    if( pots ) meta_pot += pots->totpot;
  }

  // //------------------------------------------------------------------------------

  // genie::EventRecord CAFMaker::buildEventRecord(art::Event const & evt){
  //   //Getting GTruth
  //   auto gt = evt.getHandle< std::vector<simb::GTruth> >("generator");
  //   if(!gt){
  //     std::cout << "[ERROR] Cannot build GENIEEventRecord without an available simb::GTruth" << std::endl;
  //     abort();
  //   }

  //   auto mct = evt.getHandle< std::vector<simb::MCTruth> >("generator");
  //   if(!mct) {
  //     std::cout << "[ERROR] Cannot build GENIEEventRecord without an available simb::MCTruth" << std::endl;
  //     abort();
  //   }

  //   auto gtruth = (*gt)[0];
  //   auto mctruth = (*mct)[0];

  //   genie::EventRecord rec;

  //   ///////////////////////////////////
  //   ////////Event info//////////
  //   ///////////////////////////////////
  //   rec.SetWeight(gtruth.fweight);
  //   rec.SetProbability(gtruth.fprobability);
  //   rec.SetXSec(gtruth.fXsec);
  //   rec.SetDiffXSec(gtruth.fDiffXsec, (genie::KinePhaseSpace_t) gtruth.fGPhaseSpace);
  //   rec.SetVertex(gtruth.fVertex);

  //   ///////////////////////////////////
  //   ////////interactions info//////////
  //   ///////////////////////////////////

  //   //process info
  //   genie::Interaction *inter = new genie::Interaction;
  //   genie::ProcessInfo proc_info;
  //   genie::ScatteringType_t gscty = (genie::ScatteringType_t)gtruth.fGscatter;
  //   genie::InteractionType_t ginty = (genie::InteractionType_t)gtruth.fGint;
  //   proc_info.Set(gscty,ginty);
  //   inter->SetProcInfo(proc_info);

  //   //true reaction information and byproducts
  //   //(PRE FSI)
  //   genie::XclsTag exclTag;
  //   if(gtruth.fIsCharm){
  //     exclTag.SetCharm(gtruth.fCharmHadronPdg);
  //   }
  //   if(gtruth.fIsStrange){
  //     exclTag.SetStrange(gtruth.fStrangeHadronPdg);
  //   }
  //   exclTag.SetResonance((genie::Resonance_t) gtruth.fResNum);
  //   exclTag.SetDecayMode(gtruth.fDecayMode);
  //   exclTag.SetNPions(gtruth.fNumPiPlus, gtruth.fNumPi0, gtruth.fNumPiMinus);
  //   exclTag.SetNNucleons(gtruth.fNumProton, gtruth.fNumNeutron);

  //   #if __GENIE_RELEASE_CODE__ >= GRELCODE(3,2,0)
  //     exclTag.SetNSingleGammas(gtruth.fNumSingleGammas);
  //     exclTag.SetNRhos(gtruth.fNumRhoPlus, gtruth.fNumRho0, gtruth.fNumRhoMinus);
  //     exclTag.SetFinalQuark(gtruth.fFinalQuarkPdg);
  //     exclTag.SetFinalLeptongtruth.fFinalLeptonPdg);
  //   #endif
  //   inter->SetExclTag(exclTag);

  //   //Kinematics info
  //   genie::Kinematics kine;
  //   kine.Setx(gtruth.fgX, true);
  //   kine.Sety(gtruth.fgY, true);
  //   kine.Sett(gtruth.fgT, true);
  //   kine.SetW(gtruth.fgW, true);
  //   kine.SetQ2(gtruth.fgQ2, true);
  //   kine.Setq2(gtruth.fgq2, true);
  //   kine.SetHadSystP4(gtruth.fFShadSystP4);
  //   // simb::MCNeutrino nu = truth.GetNeutrino();
  //   // simb::MCParticle lep = nu.Lepton();
  //   // gkin.SetFSLeptonP4(lep.Px(), lep.Py(), lep.Pz(), lep.E());
  //   // gkin.SetHadSystP4(gtruth.fFShadSystP4.Px(), gtruth.fFShadSystP4.Py(), gtruth.fFShadSystP4.Pz(), gtruth.fFShadSystP4.E());
  //   inter->SetKine(kine);
    
  //   //Initial State info
  //   genie::InitialState *initState = inter->InitStatePtr();
  //   initState->SetProbePdg(gtruth.fProbePDG);
  //   initState->SetProbeP4(gtruth.fProbeP4);
  //   initState->SetTgtP4(gtruth.fTgtP4);

  //   //Target info
  //   genie::Target* tgt = p_ginstate->TgtPtr();
  //   tgt->SetId(gtruth.ftgtPDG);
  //   tgt->SetHitNucP4(gtruth.fHitNucP4);
  //   tgt->SetHitNucPosition(gtruth.fHitNucPos);
  //   tgt->SetHitQrkPdg(struckQuark);
  //   tgt->SetHitSeaQrk(gtruth.fIsSeaQuark);

  //   rec.AttachSummary(inter);

  //   //===============================================

  //   return rec;
  // }

  //------------------------------------------------------------------------------
  void CAFMaker::analyze(art::Event const & evt)
  {
    caf::StandardRecord sr;

    if(fTree){
      caf::StandardRecord* psr = &sr;
      std::vector<float>* cvwgt = &(sr.cvwgt);
      std::vector<std::vector<float>>* xsSyst_wgt = &(sr.xsSyst_wgt);
      fTree->SetBranchAddress("rec", &psr);
      fTree->SetBranchAddress("cvwgt", &cvwgt);
      fTree->SetBranchAddress("xsSyst_wgt", &xsSyst_wgt);
      fTree->SetBranchAddress("genie_rec", &genie_rec);
    }

    auto pidin = evt.getHandle<dunemva::MVASelectPID>(fMVASelectLabel);
    auto pidinnue = evt.getHandle<dunemva::MVASelectPID>(fMVASelectNueLabel);
    auto pidinnumu = evt.getHandle<dunemva::MVASelectPID>(fMVASelectNumuLabel);
    art::InputTag itag1(fCVNLabel, "cvnresult");
    auto cvnin = evt.getHandle<std::vector<cvn::Result>>(itag1);
    art::InputTag itag2(fRegCNNLabel, "regcnnresult");
    auto regcnnin = evt.getHandle<std::vector<cnn::RegCNNResult>>(itag2);
    auto ereconuein = evt.getHandle<dune::EnergyRecoOutput>(fEnergyRecoNueLabel);
    auto ereconumuin = evt.getHandle<dune::EnergyRecoOutput>(fEnergyRecoNumuLabel);

    sr.run = evt.id().run();
    sr.subrun = evt.id().subRun();
    sr.event = evt.id().event();
    meta_run = sr.run;
    meta_subrun = sr.subrun;

    sr.CVNResultNue = -999;
    sr.CVNResultNumu = -999;

    if( !pidin.failedToGet() ) {
      sr.mvaresult = pidin->pid;

      //Fill MVA reco stuff
      sr.Ev_reco_nue     = ereconuein->fNuLorentzVector.E();
      sr.RecoLepEnNue    = ereconuein->fLepLorentzVector.E();
      sr.RecoHadEnNue    = ereconuein->fHadLorentzVector.E();
      sr.RecoMethodNue   = ereconuein->recoMethodUsed;
      sr.Ev_reco_numu    = ereconumuin->fNuLorentzVector.E();
      sr.RecoLepEnNumu   = ereconumuin->fLepLorentzVector.E();
      sr.RecoHadEnNumu   = ereconumuin->fHadLorentzVector.E();
      sr.RecoMethodNumu  = ereconumuin->recoMethodUsed;
      sr.LongestTrackContNumu = ereconumuin->longestTrackContained;
      sr.TrackMomMethodNumu   = ereconumuin->trackMomMethod;

      if(ereconuein->fLepLorentzVector.P() > 0){
        sr.CVNResultNue = acos(ereconuein->fLepLorentzVector.Pz()/ereconuein->fLepLorentzVector.P());
      }
      if(ereconumuin->fLepLorentzVector.P() > 0){
        sr.CVNResultNumu = acos(ereconumuin->fLepLorentzVector.Pz()/ereconumuin->fLepLorentzVector.P());
      }
      

      std::cout << "nue -> Pz: " << ereconuein->fLepLorentzVector.Pz() << " ; P: " << ereconuein->fLepLorentzVector.P() << " ; angle: " << sr.CVNResultNue << std::endl;
      std::cout << "numu -> Pz: " << ereconumuin->fLepLorentzVector.Pz() << " ; P: " << ereconumuin->fLepLorentzVector.P() << " ; angle: " << sr.CVNResultNumu << std::endl;
    }

    if( !pidinnue.failedToGet() ) {
      sr.mvanue = pidinnue->pid;
    }

    if( !pidinnumu.failedToGet() ) {
      sr.mvanumu = pidinnumu->pid;
    }

    if( !cvnin.failedToGet() ) {
      //using i = cvn::Interaction;
      //if(cvnin->empty() || (*cvnin)[0].fOutput.size() <= i::kNutauOther){
      if(cvnin->empty()){
        sr.CVNResultIsAntineutrino = sr.CVNResultNutau = sr.CVNResultNC = \
        sr.CVNResult0Protons = sr.CVNResult1Protons = sr.CVNResult2Protons = sr.CVNResultNProtons = \
        sr.CVNResult0Pions = sr.CVNResult1Pions = sr.CVNResult2Pions = sr.CVNResultNPions = \
        sr.CVNResult0Pizeros = sr.CVNResult1Pizeros = sr.CVNResult2Pizeros = sr.CVNResultNPizeros = \
        sr.CVNResult0Neutrons = sr.CVNResult1Neutrons = sr.CVNResult2Neutrons = sr.CVNResultNNeutrons = -3;
      }
      else{
        //const std::vector<float>& v = (*cvnin)[0].fOutput;
        //sr.CVNResultNue = v[i::kNueQE] + v[i::kNueRes] + v[i::kNueDIS] + v[i::kNueOther];
        //sr.CVNResultNumu = v[i::kNumuQE] + v[i::kNumuRes] + v[i::kNumuDIS] + v[i::kNumuOther];
        //sr.CVNResultNutau = v[i::kNutauQE] + v[i::kNutauRes] + v[i::kNutauDIS] + v[i::kNutauOther]

        sr.CVNResultIsAntineutrino = (*cvnin)[0].GetIsAntineutrinoProbability();

        sr.cvnnue = (*cvnin)[0].GetNueProbability();
        sr.cvnnumu = (*cvnin)[0].GetNumuProbability();
        sr.cvnnutau = (*cvnin)[0].GetNutauProbability();
        sr.cvnnc = (*cvnin)[0].GetNCProbability();

        sr.CVNResult0Protons = (*cvnin)[0].Get0protonsProbability();
        sr.CVNResult1Protons = (*cvnin)[0].Get1protonsProbability();
        sr.CVNResult2Protons = (*cvnin)[0].Get2protonsProbability();
        sr.CVNResultNProtons = (*cvnin)[0].GetNprotonsProbability();

        sr.CVNResult0Pions = (*cvnin)[0].Get0pionsProbability();
        sr.CVNResult1Pions = (*cvnin)[0].Get1pionsProbability();
        sr.CVNResult2Pions = (*cvnin)[0].Get2pionsProbability();
        sr.CVNResultNPions = (*cvnin)[0].GetNpionsProbability();

        sr.CVNResult0Pizeros = (*cvnin)[0].Get0pizerosProbability();
        sr.CVNResult1Pizeros = (*cvnin)[0].Get1pizerosProbability();
        sr.CVNResult2Pizeros = (*cvnin)[0].Get2pizerosProbability();
        sr.CVNResultNPizeros = (*cvnin)[0].GetNpizerosProbability();

        sr.CVNResult0Neutrons = (*cvnin)[0].Get0neutronsProbability();
        sr.CVNResult1Neutrons = (*cvnin)[0].Get1neutronsProbability();
        sr.CVNResult2Neutrons = (*cvnin)[0].Get2neutronsProbability();
        sr.CVNResultNNeutrons = (*cvnin)[0].GetNneutronsProbability();
      }
    }

    sr.RegCNNNueE = -1.;  // initializing
    if(!regcnnin.failedToGet()){
      if (!regcnnin->empty()){
        const std::vector<float>& v = (*regcnnin)[0].fOutput;
        sr.RegCNNNueE = v[0];
      }
    }

    auto mct = evt.getHandle< std::vector<simb::MCTruth> >("generator");
    if ( !mct ) {
      mf::LogWarning("CAFMaker") << "No MCTruth.";
        }
    else if ( !mct->empty() ) {
      FillTruthInfo(sr, *mct, evt.getProduct<std::vector<simb::MCFlux> >("generator"), evt);
      }

    if(fTree){
      fTree->Fill();
    }

    if(fFlatTree){
      fFlatRecord->Clear();
      fFlatRecord->Fill(sr);
      fFlatTree->Fill();
    }
  }

  //------------------------------------------------------------------------------

  //------------------------------------------------------------------------------
  void CAFMaker::endSubRun(const art::SubRun& sr){
  }

  void CAFMaker::endJob()
  {
    fMetaTree->Fill();

    if(fOutFile){
      fOutFile->cd();
      fTree->Write();
      fMetaTree->Write();
      fOutFile->Close();
    }

    if(fFlatFile){
      fFlatFile->cd();
      fFlatTree->Write();
      fMetaTree->Write();
      fFlatFile->Close();
    }
  }

  DEFINE_ART_MODULE(CAFMaker)

} // namespace caf

#endif // CAFMaker_H
